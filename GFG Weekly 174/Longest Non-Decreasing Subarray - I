/* PREFIX SUM + HASHMAP SEEING THE SAME SUM STATE LOGIC O(n) */
class Solution {
    public static int longestSubarray(int n, int[] arr, int k) {
        int ans=0;
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum=0;
        int start = 0;  // To track the start of the valid subarray
        for(int i=0;i<n;i++){
            if(i==0 || arr[i]>=arr[i-1]){
                sum+=arr[i];
                sum %= k;
                if(!map.containsKey(sum)) map.put(sum, i);  //storing only the first occurence
            }
            else{   //reset all values, since not sorted subarray now so restart
                map.clear();
                sum=arr[i];
                sum %= k;
                map.put(sum, i);
                start = i;  // Reset the start of the subarray
            }
            //check whether current state is solution or not
            int rem = sum % k;
            if (rem==0) ans = Math.max(ans, i-start+1); //if sum is divisible by k
            if (map.containsKey(rem)) ans=Math.max(ans, i-map.get(rem));
            else map.put(rem, i);
        }
        return ans;
    }
}
/*
LOGIC---
We need a sorted subarray with sum divisible by k.
ALGORITHM---
We create a prefix modulo sum and put the values in hahsmap to see whether we have encountered the same value or not.

We will keep track of remainder that we have seen in our hashmap. For k, it will be from 0 to k-1.

If we encounter the same sum modulo with k, again that means we can extend our previous subarray start to the current index, which will help us to get the longest required subarray. 
Case I: sum%k==0
That would mean ans = currindex - start of curr subarray + 1

Case II: sum%k!=0
That would mean ans = currindex - start of the previous subarray where sum%k existed
If map contains sum%k, use it to find ans, if not that means its encoutnered first time, store this state.
If at some idnex the sum%k is c then if that c appears again, then that means sum%k==0 is in the middle.

We will only update when we either restart or encounter new values.
*/




/* BRUTE FORCE TLE O(n^2) */
class Solution {
    public static int longestSubarray(int n, int[] nums, int k) {
        int ans=0;
        for(int i=0;i<n;i++){
            if(nums[i]%k==0) ans=Math.max(ans, 1);
            int j=i+1;
            int sum=nums[i];
            while(j<n && nums[j]>=nums[j-1]){
                sum+=nums[j];
                if(sum%k==0){
                    ans=Math.max(ans, j-i+1);
                }
                j++;
            }
        }
        return ans;
    }
}










class Solution {
    public static int longestCommonPalindrome(String str1, String str2) {
        String res1=solve(str1,str2);
        StringBuilder sb=new StringBuilder(res1);
        String res2=sb.reverse().toString();//keeg
        String res3=solve(res1,res2);//geek
        return res3.length();
    }
    
    public static String solve(String str1,String str2){
        int n=str1.length();
        int m=str2.length();
        int dp[][]=new int[n+1][m+1];
        int start=0,end=0,max=0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(str1.charAt(i-1)==str2.charAt(j-1)){
                    dp[i][j]=1+dp[i-1][j-1];
                }
                else dp[i][j]=0;
                if(dp[i][j]>max){
                    max=dp[i][j];
                    start=i;
                    end=j;
                }
            }
        }
        StringBuilder sb=new StringBuilder();
        while(dp[start][end]>0){
            sb.append(str1.charAt(start-1));
            start--;
            end--;
        }
        return sb.toString();
    }
}

/*
LOGIC---
Find longest common string between s1 and s2. Lets call it s.
Now reverse s.
The common substring between s and reverse of s will be the longest common palindrome substring.
*/


/* EXPAND AROUND CENTER O(n^2) TLE */
class Solution {
    public static int longestCommonPalindrome(String s1, String s2) {
        HashSet<String> palindromes = new HashSet<>();
        int n = s1.length();
        // Check for palindromic substrings centered at each character and between characters
        for (int center = 0; center < n; center++) {
            findPalindromes(s1, center, center, palindromes); // Odd-length palindromes
            findPalindromes(s1, center, center + 1, palindromes); // Even-length palindromes
        }
        //check for these palindrome substrings in s2
        int ans=0;
        for(String s : palindromes){
            if(s2.contains(s)) ans=Math.max(ans, s.length());
        }
        return ans;
    }
    
    private static void findPalindromes(String s, int left, int right, Set<String> palindromes) {
        while (left>=0 && right<s.length() && s.charAt(left)==s.charAt(right)) {
            palindromes.add(s.substring(left, right + 1));
            left--;
            right++;
        }
    }
}


/*
LOGIC---
Find all palindromic substring in s1 using expand around center store them in set.
Now check whether these substrings in set occurs in s2 or not.
Get the longest length.
*/